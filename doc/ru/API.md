# Протокол обмена.

## Структура сети

Связь между узлами - точка-точка

GUI - API ==== API - GUI

GUI - примитивная программа под Linux/Window/Android, которая умеет отображать сообщения и вызывать функции ядра (API). 
API - ядро мессенджера. Достаточно подключить *main.cpp*, чтобы вызывать функции ядра.

## Протокол обмена

Обмен сообщениями ведётся по UDP протоколу в формате JSON.
При любой успешной отправке данных обновляем поле last_connect у контакта.
Если пришло сообщение от контакта, которого нет в адресной книге - то оно отбрасывается.
Исключения - запрос handshake.

### Добавление в друзья

Используется, чтобы установить связь с контактом. Тот кто хочет добавиться в друзья - отправляет такой запрос.

```json
{ "peerID":"*IPv6 контакта*", "action":"handshake" }
```

ответ:

```json
{ "peerID":"*IPv6*", "action":"handshakeSuccess", "status": true }
```

У другого абонента висит этот контакт в списке неавторизованных. Если он хочет его тоже добавить в друзья - отправляем ему свой handshake. Возможет вариант, когда сервер автоматически добавляет в друзья (публичный сервер для пересылки offline сообщений).

### Отправка сообщения

Структура сообщения в JSON:

```json
{ "peerSender":"*IPv6*", "peerReceiver":"*IPv6*", "action":"send", "msgID":"*ID сообщения в чате*","msgText":"*сообщение*", "timestamp":"*время*", "enctype":"" }
```

ответ:

```json
{ "peerSender":"*IPv6 отправителя, т.е. кому доставили сообщение*", "peerReceiver":"*IPv6 получателя, т.е. кто отправил сообщение*", "action":"sendSuccess", "msgID":"*ID сообщения, которое доставлено, в чате*", "status": true }
```

Сообщение может должно быть зашифровано, метод шифрования указан в поле `enctype`.
Если нет ответа, то сохраняем сообщение у себя в истории, чтобы потом переотправить.
`status == true` - доставлено.

### Пинг - проверка онлайна

Если прошло время last_connect > 1 минуты, от отправляем запрос

```json
{ "peerID":"*IPv6*", "action":"ping" }
```

ответ:

```json
{ "peerID":"*IPv6*", "action":"pong" }
```

Если у нас есть сообщения для адреса и он онлайн (last_connect < 1 минуты), то передаём их
Если для этого адрес в базе есть недоставленные сообщения, то отправляем такой запрос:

```json
{ "action": "history", "messages":[{},{},{}...] }
```

ответ:

```json
{ "status":[1,1,1,0,1] }
```

В ответ приходит массив с 1 или 0. Если 1 - сообщение сохранено успешно, 0 - ошибка и его нужно потом переотправить.

### Отправление сообщения для другого абонента (это нужно чтобы отправлять тем, кто в offline)

Если человек, которому мы отправляем сообщение offline - то, во-первых, оно сохраняется у себя на сервере, для последующей отправки.
Во-вторых, можно попросить какого-то друга его переотправить. Для этого выбираем случайно несколько друзей из списка контактов, у которых `can_resend == 1` и отправляем им запрос.
Для ретрансляции можно также использовать свой сервер в интернете, нужно просто его добавить в контакты.

```json
{ "action":"resend", ... }
```

Параметры такие же как и для send
ответ

```json
{ "status":1 }
```

Если `status == 0` - то эта нода не желает пересылать сообщения и ей повторно отправлять не нужно.
