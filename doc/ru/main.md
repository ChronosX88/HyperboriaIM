# Общая документация мессенджера HyperboriaIM

## Структура мессенджера

Связь между узлами - точка-точка

GUI - API ==== API - GUI

GUI - примитивная программа под Linux/Windows/Android, которая умеет отображать сообщения и вызывать функции ядра (API).
API - ядро мессенджера. Достаточно подключить *main.hpp*, чтобы вызывать функции ядра. Такая структура позволяет писать какие угодно клиенты.

## Протокол обмена

Обмен сообщениями ведётся по UDP протоколу в формате JSON.
При любой успешной отправке данных обновляем поле last_connect у контакта.
Если пришло сообщение от контакта, которого нет в адресной книге - то оно отбрасывается.
Исключения - запрос handshake.

### Добавление в друзья

Используется, чтобы установить связь с контактом. Тот кто хочет добавиться в друзья - отправляет такой запрос:

```json
{
  "action":"handshake",
  "peerID":"*IPv6 контакта*"
}
```

Ответ:

```json
{
  "action":"handshakeSuccess",
  "peerID":"*IPv6*",
  "status": true
}
```

У другого абонента висит этот контакт в списке неавторизованных. Если он хочет его тоже добавить в друзья - отправляем ему свой handshake. Возможет вариант, когда сервер автоматически добавляет в друзья (публичный сервер для пересылки offline сообщений).

### Отправка сообщения

Структура сообщения в JSON:

```json
{
  "action":"send",
  "peerSender":"*IPv6*",
  "peerReceiver":"*IPv6*",
  "chatID":"*Идентификатор чата, у обоих он одинаковый*",
  "msgID":"*ID сообщения в чате*","msgText":"*сообщение*",
  "timestamp":"*время*",
  "enctype":""
}
```

ответ:

```json
{
  "action":"sendSuccess",
  "peerSender":"*IPv6 отправителя, т.е. кому доставили сообщение*",
  "peerReceiver":"*IPv6 получателя, т.е. кто отправил сообщение*",
  "chatID":"*Идентификатор чата, у обоих он одинаковый*",
  "msgID":"*ID сообщения, которое доставлено, в чате*",
  "status": true
}
```

Сообщение может должно быть зашифровано, метод шифрования указан в поле `enctype`.
Если нет ответа, то сохраняем сообщение у себя в истории, чтобы потом переотправить.
`status == true` - доставлено.

### Пинг - проверка онлайна

Если прошло время last_connect > 1 минуты, от отправляем запрос

```json
{
  "action":"ping",
  "peerID":"*IPv6*"
}
```

ответ:

```json
{
  "action":"pong",
  "peerID":"*IPv6*"
}
```

Если у нас есть сообщения для адреса и он онлайн (last_connect < 1 минуты), то передаём их.
Если для этого адрес в базе есть недоставленные сообщения, то отправляем такой запрос:

```json
{
  "action":"history",
  "messages":[{},{},{}]
}
```

ответ:

```json
{
  "action":"historySuccess",
  "status":[true,true,true,false,true]
}
```

В ответ приходит массив с `true` или `false`. Если `true` - сообщение успешно отправлено, `false` - сообщение недоставлено.

### Отправление сообщения для другого абонента (это нужно чтобы отправлять тем, кто в offline)

Если человек, которому мы отправляем сообщение offline - то, во-первых, оно сохраняется у себя на сервере, для последующей отправки.
Во-вторых, можно попросить какого-то друга его переотправить. Для этого выбираем случайно несколько друзей из списка контактов, у которых `can_resend == 1` и отправляем им запрос.
Для ретрансляции можно также использовать свой сервер в интернете, нужно просто его добавить в контакты.

```json
{
  "peerSender":"*IPv6*",
  "peerReceiver":"*IPv6*",
  "action":"resend",
  "chatID":"*Идентификатор чата, у обоих он одинаковый*",
  "msgID":"*ID сообщения в чате*",
  "msgText":"*сообщение*",
  "timestamp":"*время*",
  "enctype":""
}
```

Ответ:

```json
{
  "peerID":"*IPv6*",
  "action":"resendSuccess",
  "status": true
}
```

Если `status == 0` - то эта нода не желает пересылать сообщения и ей повторно отправлять не нужно.

### Генерация любых уникальных идентификаторов (UUID)
Генерация любых уникальных идентификаторов в мессенджере осуществляется с помощью класса *QUuid* в *Qt*. Используется функция `QUuid::createUuid()` без аргументов.
